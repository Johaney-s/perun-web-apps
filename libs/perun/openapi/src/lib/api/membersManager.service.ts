/**
 * Perun RPC API
 * Perun Remote Procedure Calls Application Programming Interface
 *
 * The version of the OpenAPI document: 0.0.0
 * Contact: perun@cesnet.cz
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { InputCreateMemberForCandidate } from '../model/inputCreateMemberForCandidate';
// @ts-ignore
import { InputCreateMemberForUser } from '../model/inputCreateMemberForUser';
// @ts-ignore
import { InputCreateMemberFromExtSource } from '../model/inputCreateMemberFromExtSource';
// @ts-ignore
import { InputCreateSponsoredMember } from '../model/inputCreateSponsoredMember';
// @ts-ignore
import { InputCreateSponsoredMemberFromCSV } from '../model/inputCreateSponsoredMemberFromCSV';
// @ts-ignore
import { InputCreateSponsoredMembers } from '../model/inputCreateSponsoredMembers';
// @ts-ignore
import { InputGetPaginatedMembers } from '../model/inputGetPaginatedMembers';
// @ts-ignore
import { InputSetSponsoredMember } from '../model/inputSetSponsoredMember';
// @ts-ignore
import { InputSpecificMember } from '../model/inputSpecificMember';
// @ts-ignore
import { Member } from '../model/member';
// @ts-ignore
import { MemberWithSponsors } from '../model/memberWithSponsors';
// @ts-ignore
import { NamespaceRules } from '../model/namespaceRules';
// @ts-ignore
import { PaginatedRichMembers } from '../model/paginatedRichMembers';
// @ts-ignore
import { PerunException } from '../model/perunException';
// @ts-ignore
import { RichMember } from '../model/richMember';
// @ts-ignore
import { RichUser } from '../model/richUser';
// @ts-ignore
import { VoMemberStatuses } from '../model/voMemberStatuses';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class MembersManagerService {

    protected basePath = 'https://api-dev.perun-aai.org/ba/rpc';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }


    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substr(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Return true if the membership can be extended or if no rules were set for the membershipExpiration, otherwise false.
     * @param member id of Member
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public canExtendMembership(member: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<boolean>;
    public canExtendMembership(member: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<boolean>>;
    public canExtendMembership(member: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<boolean>>;
    public canExtendMembership(member: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling canExtendMembership.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/canExtendMembership`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<boolean>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new member from candidate returned by the method VosManager.findCandidates which fills Candidate.userExtSource. This method also add user to all groups in list. Empty list of groups is ok, the behavior is then same like in the method without list of groups. This method runs asynchronously
     * @param InputCreateMemberForCandidate 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMemberForCandidate(InputCreateMemberForCandidate: InputCreateMemberForCandidate, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public createMemberForCandidate(InputCreateMemberForCandidate: InputCreateMemberForCandidate, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public createMemberForCandidate(InputCreateMemberForCandidate: InputCreateMemberForCandidate, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public createMemberForCandidate(InputCreateMemberForCandidate: InputCreateMemberForCandidate, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputCreateMemberForCandidate === null || InputCreateMemberForCandidate === undefined) {
            throw new Error('Required parameter InputCreateMemberForCandidate was null or undefined when calling createMemberForCandidate.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createMember/c`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Member>(requestUrl,
            InputCreateMemberForCandidate,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new member from user. This method also add user to all groups in list. Empty list of groups is ok, the behavior is then same like in the method without list of groups.
     * @param InputCreateMemberForUser 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMemberForUser(InputCreateMemberForUser: InputCreateMemberForUser, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public createMemberForUser(InputCreateMemberForUser: InputCreateMemberForUser, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public createMemberForUser(InputCreateMemberForUser: InputCreateMemberForUser, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public createMemberForUser(InputCreateMemberForUser: InputCreateMemberForUser, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputCreateMemberForUser === null || InputCreateMemberForUser === undefined) {
            throw new Error('Required parameter InputCreateMemberForUser was null or undefined when calling createMemberForUser.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createMember/u`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Member>(requestUrl,
            InputCreateMemberForUser,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new member and sets all member\&#39;s attributes from the candidate. Also stores the associated user if doesn\&#39;t exist. This method is used by the registrar. This method also add user to all groups in list. Empty list of groups is ok, the behavior is then same like in the method without list of groups.
     * @param InputCreateMemberFromExtSource 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createMemberFromExtSource(InputCreateMemberFromExtSource: InputCreateMemberFromExtSource, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public createMemberFromExtSource(InputCreateMemberFromExtSource: InputCreateMemberFromExtSource, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public createMemberFromExtSource(InputCreateMemberFromExtSource: InputCreateMemberFromExtSource, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public createMemberFromExtSource(InputCreateMemberFromExtSource: InputCreateMemberFromExtSource, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputCreateMemberFromExtSource === null || InputCreateMemberFromExtSource === undefined) {
            throw new Error('Required parameter InputCreateMemberFromExtSource was null or undefined when calling createMemberFromExtSource.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createMember/extSource`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Member>(requestUrl,
            InputCreateMemberFromExtSource,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new member from candidate which is prepared for creating specificUser.
     * @param InputSpecificMember 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSpecificMember(InputSpecificMember: InputSpecificMember, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public createSpecificMember(InputSpecificMember: InputSpecificMember, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public createSpecificMember(InputSpecificMember: InputSpecificMember, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public createSpecificMember(InputSpecificMember: InputSpecificMember, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputSpecificMember === null || InputSpecificMember === undefined) {
            throw new Error('Required parameter InputSpecificMember was null or undefined when calling createSpecificMember.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createSpecificMember`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Member>(requestUrl,
            InputSpecificMember,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a new sponsored member in a given VO and namespace.
     * @param InputCreateSponsoredMember 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSponsoredMember(InputCreateSponsoredMember: InputCreateSponsoredMember, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RichMember>;
    public createSponsoredMember(InputCreateSponsoredMember: InputCreateSponsoredMember, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RichMember>>;
    public createSponsoredMember(InputCreateSponsoredMember: InputCreateSponsoredMember, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RichMember>>;
    public createSponsoredMember(InputCreateSponsoredMember: InputCreateSponsoredMember, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputCreateSponsoredMember === null || InputCreateSponsoredMember === undefined) {
            throw new Error('Required parameter InputCreateSponsoredMember was null or undefined when calling createSponsoredMember.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createSponsoredMember/withFullName`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<RichMember>(requestUrl,
            InputCreateSponsoredMember,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates new sponsored members in a given VO and namespace.
     * @param InputCreateSponsoredMembers 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSponsoredMembers(InputCreateSponsoredMembers: InputCreateSponsoredMembers, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<{ [key: string]: string; }>>;
    public createSponsoredMembers(InputCreateSponsoredMembers: InputCreateSponsoredMembers, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<{ [key: string]: string; }>>>;
    public createSponsoredMembers(InputCreateSponsoredMembers: InputCreateSponsoredMembers, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<{ [key: string]: string; }>>>;
    public createSponsoredMembers(InputCreateSponsoredMembers: InputCreateSponsoredMembers, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputCreateSponsoredMembers === null || InputCreateSponsoredMembers === undefined) {
            throw new Error('Required parameter InputCreateSponsoredMembers was null or undefined when calling createSponsoredMembers.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createSponsoredMembers`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Array<{ [key: string]: string; }>>(requestUrl,
            InputCreateSponsoredMembers,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates new sponsored members in a given VO and namespace.
     * @param InputCreateSponsoredMemberFromCSV 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createSponsoredMembersFromCSV(InputCreateSponsoredMemberFromCSV: InputCreateSponsoredMemberFromCSV, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<{ [key: string]: string; }>>;
    public createSponsoredMembersFromCSV(InputCreateSponsoredMemberFromCSV: InputCreateSponsoredMemberFromCSV, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<{ [key: string]: string; }>>>;
    public createSponsoredMembersFromCSV(InputCreateSponsoredMemberFromCSV: InputCreateSponsoredMemberFromCSV, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<{ [key: string]: string; }>>>;
    public createSponsoredMembersFromCSV(InputCreateSponsoredMemberFromCSV: InputCreateSponsoredMemberFromCSV, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputCreateSponsoredMemberFromCSV === null || InputCreateSponsoredMemberFromCSV === undefined) {
            throw new Error('Required parameter InputCreateSponsoredMemberFromCSV was null or undefined when calling createSponsoredMembersFromCSV.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/createSponsoredMembersFromCSV`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Array<{ [key: string]: string; }>>(requestUrl,
            InputCreateSponsoredMemberFromCSV,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Deletes only member data appropriated by member id.
     * @param member id of Member
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMember(member: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public deleteMember(member: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public deleteMember(member: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public deleteMember(member: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling deleteMember.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/deleteMember`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete members with given ids. It is possible to delete members from multiple vos.
     * @param members id of Member
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteMembers(members: Array<number>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public deleteMembers(members: Array<number>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public deleteMembers(members: Array<number>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public deleteMembers(members: Array<number>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (members === null || members === undefined) {
            throw new Error('Required parameter members was null or undefined when calling deleteMembers.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (members) {
            members.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'members[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/deleteMembers`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Extend member membership using membershipExpirationRules attribute defined at VO.
     * @param member id of Member
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public extendMembership(member: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public extendMembership(member: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public extendMembership(member: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public extendMembership(member: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling extendMembership.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/extendMembership`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return list of richMembers from perun by the searchString with attributes specific for list of attrsNames and who have only status which is contain in list of statuses. If attrsNames is empty or null return all attributes for specific richMembers. If listOfStatuses is empty or null, return all possible statuses.
     * @param attrsNames list of attribute names List&lt;String&gt;
     * @param searchString Text to search by
     * @param allowedStatuses list of allowed statuses List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCompleteRichMembersByAttributes(attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public findCompleteRichMembersByAttributes(attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public findCompleteRichMembersByAttributes(attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public findCompleteRichMembersByAttributes(attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (attrsNames === null || attrsNames === undefined) {
            throw new Error('Required parameter attrsNames was null or undefined when calling findCompleteRichMembersByAttributes.');
        }
        if (searchString === null || searchString === undefined) {
            throw new Error('Required parameter searchString was null or undefined when calling findCompleteRichMembersByAttributes.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }
        if (searchString !== undefined && searchString !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchString, 'searchString');
        }
        if (allowedStatuses) {
            allowedStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedStatuses[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/findCompleteRichMembers/attrs`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return list of richMembers for specific group by the searchString with attributes specific for list of attrsNames and who have only status which is contain in lists of statuses. If attrsNames is empty or null return all attributes for specific richMembers. If listOfStatuses or listOfGroupStatuses is empty or null, return all possible statuses. If lookingInParentGroup is true, find all these richMembers only for parentGroup of this group. If this group is top level group, so find richMembers from members group.
     * @param group id of Group
     * @param attrsNames list of attribute names List&lt;String&gt;
     * @param searchString Text to search by
     * @param lookingInParentGroup If true, look up in a parent group
     * @param allowedStatuses list of allowed statuses List&lt;String&gt;
     * @param allowedGroupStatuses list of allowed group statuses List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCompleteRichMembersForGroup(group: number, attrsNames: Array<string>, searchString: string, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public findCompleteRichMembersForGroup(group: number, attrsNames: Array<string>, searchString: string, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public findCompleteRichMembersForGroup(group: number, attrsNames: Array<string>, searchString: string, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public findCompleteRichMembersForGroup(group: number, attrsNames: Array<string>, searchString: string, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling findCompleteRichMembersForGroup.');
        }
        if (attrsNames === null || attrsNames === undefined) {
            throw new Error('Required parameter attrsNames was null or undefined when calling findCompleteRichMembersForGroup.');
        }
        if (searchString === null || searchString === undefined) {
            throw new Error('Required parameter searchString was null or undefined when calling findCompleteRichMembersForGroup.');
        }
        if (lookingInParentGroup === null || lookingInParentGroup === undefined) {
            throw new Error('Required parameter lookingInParentGroup was null or undefined when calling findCompleteRichMembersForGroup.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>group, 'group');
        }
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }
        if (allowedStatuses) {
            allowedStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedStatuses[]');
            })
        }
        if (allowedGroupStatuses) {
            allowedGroupStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedGroupStatuses[]');
            })
        }
        if (searchString !== undefined && searchString !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchString, 'searchString');
        }
        if (lookingInParentGroup !== undefined && lookingInParentGroup !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>lookingInParentGroup, 'lookingInParentGroup');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/findCompleteRichMembers/g`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return list of richMembers for specific vo by the searchString with attributes specific for list of attrsNames and who have only status which is contain in list of statuses. If attrsNames is empty or null return all attributes for specific richMembers. If listOfStatuses is empty or null, return all possible statuses.
     * @param vo id of Vo
     * @param attrsNames list of attribute names List&lt;String&gt;
     * @param searchString Text to search by
     * @param allowedStatuses list of allowed statuses List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public findCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public findCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public findCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, allowedStatuses?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling findCompleteRichMembersForVo.');
        }
        if (attrsNames === null || attrsNames === undefined) {
            throw new Error('Required parameter attrsNames was null or undefined when calling findCompleteRichMembersForVo.');
        }
        if (searchString === null || searchString === undefined) {
            throw new Error('Required parameter searchString was null or undefined when calling findCompleteRichMembersForVo.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }
        if (allowedStatuses) {
            allowedStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedStatuses[]');
            })
        }
        if (searchString !== undefined && searchString !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchString, 'searchString');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/findCompleteRichMembers/v`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Searches for members in a VO.
     * @param vo id of Vo
     * @param searchString Text to search by
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findMembersInVo(vo: number, searchString: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Member>>;
    public findMembersInVo(vo: number, searchString: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Member>>>;
    public findMembersInVo(vo: number, searchString: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Member>>>;
    public findMembersInVo(vo: number, searchString: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling findMembersInVo.');
        }
        if (searchString === null || searchString === undefined) {
            throw new Error('Required parameter searchString was null or undefined when calling findMembersInVo.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (searchString !== undefined && searchString !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchString, 'searchString');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/findMembersInVo`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<Member>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of RichMembers for vo, with reqested attributes, filterd by search string and option to return only sponosred members.
     * @param vo id of Vo
     * @param attrsNames list of attribute names List&lt;String&gt;
     * @param searchString Text to search by
     * @param onlySponsored Boolean specifying if only sponsored members should be returned
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findSponsoredCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, onlySponsored: boolean, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public findSponsoredCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, onlySponsored: boolean, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public findSponsoredCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, onlySponsored: boolean, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public findSponsoredCompleteRichMembersForVo(vo: number, attrsNames: Array<string>, searchString: string, onlySponsored: boolean, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling findSponsoredCompleteRichMembersForVo.');
        }
        if (attrsNames === null || attrsNames === undefined) {
            throw new Error('Required parameter attrsNames was null or undefined when calling findSponsoredCompleteRichMembersForVo.');
        }
        if (searchString === null || searchString === undefined) {
            throw new Error('Required parameter searchString was null or undefined when calling findSponsoredCompleteRichMembersForVo.');
        }
        if (onlySponsored === null || onlySponsored === undefined) {
            throw new Error('Required parameter onlySponsored was null or undefined when calling findSponsoredCompleteRichMembersForVo.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }
        if (searchString !== undefined && searchString !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>searchString, 'searchString');
        }
        if (onlySponsored !== undefined && onlySponsored !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>onlySponsored, 'onlySponsored');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/findCompleteRichMembers/v-sponsored`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all members from all vos.
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllMembers(useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Member>>;
    public getAllMembers(useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Member>>>;
    public getAllMembers(useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Member>>>;
    public getAllMembers(useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getAllMembers`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<Member>>(requestUrl,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Return all loaded namespaces rules.
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllNamespacesRules(useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<NamespaceRules>>;
    public getAllNamespacesRules(useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<NamespaceRules>>>;
    public getAllNamespacesRules(useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<NamespaceRules>>>;
    public getAllNamespacesRules(useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getAllNamespacesRules`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<NamespaceRules>>(requestUrl,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets all sponsored members from VO.
     * @param vo id of Vo
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllSponsoredMembers(vo: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getAllSponsoredMembers(vo: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getAllSponsoredMembers(vo: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getAllSponsoredMembers(vo: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getAllSponsoredMembers.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getAllSponsoredMembers`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets list of VO\&#39;s all sponsored members with sponsors.
     * @param vo id of Vo
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getAllSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<MemberWithSponsors>>;
    public getAllSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<MemberWithSponsors>>>;
    public getAllSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<MemberWithSponsors>>>;
    public getAllSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getAllSponsoredMembersAndTheirSponsors.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getAllSponsoredMembersAndTheirSponsors.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getAllSponsoredMembersAndTheirSponsors`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<MemberWithSponsors>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all RichMembers with attributes specific for list of attrsNames from the group and have only status which is contain in lists of statuses. If attrsNames is empty or null return all attributes for specific richMembers. If listOfStatuses or listOfGroupStatuses is empty or null, return all possible statuses. If lookingInParentGroup is true, get all these richMembers only for parentGroup of this group. If this group is top level group, so get richMembers from members group.
     * @param group id of Group
     * @param lookingInParentGroup If true, look up in a parent group
     * @param allowedStatuses list of allowed statuses List&lt;String&gt;
     * @param allowedGroupStatuses list of allowed group statuses List&lt;String&gt;
     * @param attrsNames list of attributes names List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompleteRichMembersForGroup(group: number, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, attrsNames?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getCompleteRichMembersForGroup(group: number, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, attrsNames?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getCompleteRichMembersForGroup(group: number, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, attrsNames?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getCompleteRichMembersForGroup(group: number, lookingInParentGroup: boolean, allowedStatuses?: Array<string>, allowedGroupStatuses?: Array<'VALID' | 'EXPIRED'>, attrsNames?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getCompleteRichMembersForGroup.');
        }
        if (lookingInParentGroup === null || lookingInParentGroup === undefined) {
            throw new Error('Required parameter lookingInParentGroup was null or undefined when calling getCompleteRichMembersForGroup.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>group, 'group');
        }
        if (allowedStatuses) {
            allowedStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedStatuses[]');
            })
        }
        if (allowedGroupStatuses) {
            allowedGroupStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedGroupStatuses[]');
            })
        }
        if (lookingInParentGroup !== undefined && lookingInParentGroup !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>lookingInParentGroup, 'lookingInParentGroup');
        }
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getCompleteRichMembers/g`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all RichMembers with attributes specific for list of attrsNames. Attributes are defined by member (user) and resource (facility) objects. It returns also user-facility (in userAttributes of RichMember) and member-resource (in memberAttributes of RichMember) attributes. Members are defined by group and are filtered by list of allowed statuses.
     * @param group id of Group
     * @param resource id of Resource
     * @param attrsNames list of attribute names List&lt;String&gt;
     * @param allowedStatuses list of allowed statuses List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompleteRichMembersForGroupResource(group: number, resource: number, attrsNames: Array<string>, allowedStatuses: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getCompleteRichMembersForGroupResource(group: number, resource: number, attrsNames: Array<string>, allowedStatuses: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getCompleteRichMembersForGroupResource(group: number, resource: number, attrsNames: Array<string>, allowedStatuses: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getCompleteRichMembersForGroupResource(group: number, resource: number, attrsNames: Array<string>, allowedStatuses: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (group === null || group === undefined) {
            throw new Error('Required parameter group was null or undefined when calling getCompleteRichMembersForGroupResource.');
        }
        if (resource === null || resource === undefined) {
            throw new Error('Required parameter resource was null or undefined when calling getCompleteRichMembersForGroupResource.');
        }
        if (attrsNames === null || attrsNames === undefined) {
            throw new Error('Required parameter attrsNames was null or undefined when calling getCompleteRichMembersForGroupResource.');
        }
        if (allowedStatuses === null || allowedStatuses === undefined) {
            throw new Error('Required parameter allowedStatuses was null or undefined when calling getCompleteRichMembersForGroupResource.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (group !== undefined && group !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>group, 'group');
        }
        if (resource !== undefined && resource !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>resource, 'resource');
        }
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }
        if (allowedStatuses) {
            allowedStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedStatuses[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getCompleteRichMembers/g-r`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get all RichMembers with attributes specific for list of attrsNames from the vo and have only status which is contain in list of statuses. If attrsNames is empty or null return all attributes for specific richMembers. If listOfStatuses is empty or null, return all possible statuses.
     * @param vo id of Vo
     * @param allowedStatuses list of allowed statuses List&lt;String&gt;
     * @param attrsNames list of attributes names List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getCompleteRichMembersForVo(vo: number, allowedStatuses?: Array<string>, attrsNames?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getCompleteRichMembersForVo(vo: number, allowedStatuses?: Array<string>, attrsNames?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getCompleteRichMembersForVo(vo: number, allowedStatuses?: Array<string>, attrsNames?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getCompleteRichMembersForVo(vo: number, allowedStatuses?: Array<string>, attrsNames?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getCompleteRichMembersForVo.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (allowedStatuses) {
            allowedStatuses.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'allowedStatuses[]');
            })
        }
        if (attrsNames) {
            attrsNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrsNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getCompleteRichMembers/v`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Searches for members in a VO.
     * @param vo id of Vo
     * @param extLogin external login of user, e.g. john
     * @param extSourceName external source name, e.g. IdP entityId
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberByExtSourceNameAndExtLogin(vo: number, extLogin: string, extSourceName: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public getMemberByExtSourceNameAndExtLogin(vo: number, extLogin: string, extSourceName: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public getMemberByExtSourceNameAndExtLogin(vo: number, extLogin: string, extSourceName: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public getMemberByExtSourceNameAndExtLogin(vo: number, extLogin: string, extSourceName: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getMemberByExtSourceNameAndExtLogin.');
        }
        if (extLogin === null || extLogin === undefined) {
            throw new Error('Required parameter extLogin was null or undefined when calling getMemberByExtSourceNameAndExtLogin.');
        }
        if (extSourceName === null || extSourceName === undefined) {
            throw new Error('Required parameter extSourceName was null or undefined when calling getMemberByExtSourceNameAndExtLogin.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (extLogin !== undefined && extLogin !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>extLogin, 'extLogin');
        }
        if (extSourceName !== undefined && extSourceName !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>extSourceName, 'extSourceName');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMemberByExtSourceNameAndExtLogin`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Member>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns Member by its id.
     * Gets Member
     * @param id numeric id
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberById(id: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public getMemberById(id: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public getMemberById(id: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public getMemberById(id: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getMemberById.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMemberById`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Member>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns a Member specified by VO id and User id.
     * @param vo id of Vo
     * @param user id of User
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMemberByUser(vo: number, user: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public getMemberByUser(vo: number, user: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public getMemberByUser(vo: number, user: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public getMemberByUser(vo: number, user: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getMemberByUser.');
        }
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMemberByUser.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (user !== undefined && user !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>user, 'user');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMemberByUser`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Member>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns members of a VO.
     * @param vo id of Vo
     * @param status optional status
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembers(vo: number, status?: VoMemberStatuses, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Member>>;
    public getMembers(vo: number, status?: VoMemberStatuses, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Member>>>;
    public getMembers(vo: number, status?: VoMemberStatuses, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Member>>>;
    public getMembers(vo: number, status?: VoMemberStatuses, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getMembers.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (status !== undefined && status !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>status, 'status');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMembers`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<Member>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of Members by their ids.
     * @param ids list of ids List&lt;Integer&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembersByIds(ids: Array<number>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Member>>;
    public getMembersByIds(ids: Array<number>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Member>>>;
    public getMembersByIds(ids: Array<number>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Member>>>;
    public getMembersByIds(ids: Array<number>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling getMembersByIds.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids) {
            ids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ids[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMembersByIds`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<Member>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns members for a user.
     * @param user id of User
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembersByUser(user: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<Member>>;
    public getMembersByUser(user: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<Member>>>;
    public getMembersByUser(user: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<Member>>>;
    public getMembersByUser(user: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (user === null || user === undefined) {
            throw new Error('Required parameter user was null or undefined when calling getMembersByUser.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (user !== undefined && user !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>user, 'user');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMembersByUser`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<Member>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns count of all VO members.
     * @param vo id of Vo
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembersCount(vo: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<number>;
    public getMembersCount(vo: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<number>>;
    public getMembersCount(vo: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<number>>;
    public getMembersCount(vo: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getMembersCount.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMembersCount`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<number>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get page of members from the given vo, with the given attributes.
     * @param InputGetPaginatedMembers 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembersPage(InputGetPaginatedMembers: InputGetPaginatedMembers, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<PaginatedRichMembers>;
    public getMembersPage(InputGetPaginatedMembers: InputGetPaginatedMembers, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<PaginatedRichMembers>>;
    public getMembersPage(InputGetPaginatedMembers: InputGetPaginatedMembers, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<PaginatedRichMembers>>;
    public getMembersPage(InputGetPaginatedMembers: InputGetPaginatedMembers, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputGetPaginatedMembers === null || InputGetPaginatedMembers === undefined) {
            throw new Error('Required parameter InputGetPaginatedMembers was null or undefined when calling getMembersPage.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMembersPage`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<PaginatedRichMembers>(requestUrl,
            InputGetPaginatedMembers,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns count of VO members with specified status.
     * @param vo id of Vo
     * @param status status (VALID | INVALID | EXPIRED | DISABLED)
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getMembersWithStatusCount(vo: number, status: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<number>;
    public getMembersWithStatusCount(vo: number, status: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<number>>;
    public getMembersWithStatusCount(vo: number, status: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<number>>;
    public getMembersWithStatusCount(vo: number, status: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getMembersWithStatusCount.');
        }
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling getMembersWithStatusCount.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (status !== undefined && status !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>status, 'status');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getMembersCount/status`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<number>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns RichMember by member id.
     * Get RichMember without attributes
     * @param id numeric id
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRichMember(id: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RichMember>;
    public getRichMember(id: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RichMember>>;
    public getRichMember(id: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RichMember>>;
    public getRichMember(id: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRichMember.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getRichMember`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<RichMember>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns Member by its id.
     * Get richMember with member/user attributes
     * @param id numeric id
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRichMemberWithAttributes(id: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RichMember>;
    public getRichMemberWithAttributes(id: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RichMember>>;
    public getRichMemberWithAttributes(id: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RichMember>>;
    public getRichMemberWithAttributes(id: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRichMemberWithAttributes.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (id !== undefined && id !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>id, 'id');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getRichMemberWithAttributes`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<RichMember>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns rich members by their IDs with specific attributes. When the list of attribute names is null or empty then rich members will be returned without attributes.
     * @param ids list of ids List&lt;Integer&gt;
     * @param attrNames list of attribute names List&lt;String&gt; or null
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRichMembersByIds(ids: Array<number>, attrNames?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getRichMembersByIds(ids: Array<number>, attrNames?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getRichMembersByIds(ids: Array<number>, attrNames?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getRichMembersByIds(ids: Array<number>, attrNames?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (ids === null || ids === undefined) {
            throw new Error('Required parameter ids was null or undefined when calling getRichMembersByIds.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (ids) {
            ids.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'ids[]');
            })
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getRichMembersByIds`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Returns list of all RichMembers for specified VO. User attributes aren\&#39;t included in the returned objects
     * Get richMembers for VO with member attributes (without user attributes).
     * @param vo id of Vo
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getRichMembersNoUserAttributes(vo: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getRichMembersNoUserAttributes(vo: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getRichMembersNoUserAttributes(vo: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getRichMembersNoUserAttributes(vo: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getRichMembersNoUserAttributes.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getRichMembersNoUserAttributes`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets members from VO who are sponsored.
     * @param vo id of Vo
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSponsoredMembers(vo: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichMember>>;
    public getSponsoredMembers(vo: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichMember>>>;
    public getSponsoredMembers(vo: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichMember>>>;
    public getSponsoredMembers(vo: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getSponsoredMembers.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getSponsoredMembers/v`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichMember>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets list of members with sponsors.
     * @param vo id of Vo
     * @param attrNames list of attribute names List&lt;String&gt;
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<MemberWithSponsors>>;
    public getSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<MemberWithSponsors>>>;
    public getSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<MemberWithSponsors>>>;
    public getSponsoredMembersAndTheirSponsors(vo: number, attrNames: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getSponsoredMembersAndTheirSponsors.');
        }
        if (attrNames === null || attrNames === undefined) {
            throw new Error('Required parameter attrNames was null or undefined when calling getSponsoredMembersAndTheirSponsors.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getSponsoredMembersAndTheirSponsors`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<MemberWithSponsors>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets sponsors for given member with optional attribute names.
     * @param member id of Member
     * @param attrNames list of attribute names List&lt;String&gt; or null
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSponsorsByMember(member: number, attrNames?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichUser>>;
    public getSponsorsByMember(member: number, attrNames?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichUser>>>;
    public getSponsorsByMember(member: number, attrNames?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichUser>>>;
    public getSponsorsByMember(member: number, attrNames?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling getSponsorsByMember.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getSponsors/member`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichUser>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets sponsors for given VO, extSourceName and extLogin with optional attribute names.
     * @param vo id of Vo
     * @param extSourceName external source name, e.g. IdP entityId
     * @param extLogin external login of user, e.g. john
     * @param attrNames list of attribute names List&lt;String&gt; or null
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getSponsorsByVo(vo: number, extSourceName: string, extLogin: string, attrNames?: Array<string>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Array<RichUser>>;
    public getSponsorsByVo(vo: number, extSourceName: string, extLogin: string, attrNames?: Array<string>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Array<RichUser>>>;
    public getSponsorsByVo(vo: number, extSourceName: string, extLogin: string, attrNames?: Array<string>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Array<RichUser>>>;
    public getSponsorsByVo(vo: number, extSourceName: string, extLogin: string, attrNames?: Array<string>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling getSponsorsByVo.');
        }
        if (extSourceName === null || extSourceName === undefined) {
            throw new Error('Required parameter extSourceName was null or undefined when calling getSponsorsByVo.');
        }
        if (extLogin === null || extLogin === undefined) {
            throw new Error('Required parameter extLogin was null or undefined when calling getSponsorsByVo.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (extSourceName !== undefined && extSourceName !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>extSourceName, 'extSourceName');
        }
        if (extLogin !== undefined && extLogin !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>extLogin, 'extLogin');
        }
        if (attrNames) {
            attrNames.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'attrNames[]');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/getSponsors/vo`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.get<Array<RichUser>>(requestUrl,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Moves membership in VO from source user to target user - moves the source user\&#39;s memberships in non-synchronized groups, member related attributes, bans and sponsorships in the VO. Removes the source user\&#39;s member object. If VO is member of any hierarchical parent VO, user\&#39;s membership is moved in parent VOs also. If VO is parent of any hierarchical member VOs, user\&#39;s membership is not moved in member VOs.
     * @param vo id of Vo
     * @param sourceUser id of source user
     * @param targetUser id of target user
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public moveMembership(vo: number, sourceUser: number, targetUser: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public moveMembership(vo: number, sourceUser: number, targetUser: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public moveMembership(vo: number, sourceUser: number, targetUser: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public moveMembership(vo: number, sourceUser: number, targetUser: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (vo === null || vo === undefined) {
            throw new Error('Required parameter vo was null or undefined when calling moveMembership.');
        }
        if (sourceUser === null || sourceUser === undefined) {
            throw new Error('Required parameter sourceUser was null or undefined when calling moveMembership.');
        }
        if (targetUser === null || targetUser === undefined) {
            throw new Error('Required parameter targetUser was null or undefined when calling moveMembership.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (vo !== undefined && vo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>vo, 'vo');
        }
        if (sourceUser !== undefined && sourceUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sourceUser, 'sourceUser');
        }
        if (targetUser !== undefined && targetUser !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>targetUser, 'targetUser');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/moveMembership`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes sponsor of existing member.
     * @param member id of Member
     * @param sponsor id of sponsor
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeSponsor(member: number, sponsor: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public removeSponsor(member: number, sponsor: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public removeSponsor(member: number, sponsor: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public removeSponsor(member: number, sponsor: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling removeSponsor.');
        }
        if (sponsor === null || sponsor === undefined) {
            throw new Error('Required parameter sponsor was null or undefined when calling removeSponsor.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (sponsor !== undefined && sponsor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sponsor, 'sponsor');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/removeSponsor`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Removes sponsors of existing member.
     * @param member id of Member
     * @param sponsorIds list of ids of sponsors
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public removeSponsors(member: number, sponsorIds: Array<number>, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public removeSponsors(member: number, sponsorIds: Array<number>, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public removeSponsors(member: number, sponsorIds: Array<number>, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public removeSponsors(member: number, sponsorIds: Array<number>, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling removeSponsors.');
        }
        if (sponsorIds === null || sponsorIds === undefined) {
            throw new Error('Required parameter sponsorIds was null or undefined when calling removeSponsors.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (sponsorIds) {
            sponsorIds.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sponsorIds');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/removeSponsors`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send mail to user\&#39;s preferred email address with link for non-authz account activation. Correct authz information is stored in link\&#39;s URL.
     * @param member id of Member
     * @param namespace namespace
     * @param emailAttributeURN urn of the attribute with stored mail
     * @param language language of the message
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendAccountActivationLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public sendAccountActivationLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public sendAccountActivationLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public sendAccountActivationLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling sendAccountActivationLinkEmail.');
        }
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling sendAccountActivationLinkEmail.');
        }
        if (emailAttributeURN === null || emailAttributeURN === undefined) {
            throw new Error('Required parameter emailAttributeURN was null or undefined when calling sendAccountActivationLinkEmail.');
        }
        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling sendAccountActivationLinkEmail.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (namespace !== undefined && namespace !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>namespace, 'namespace');
        }
        if (emailAttributeURN !== undefined && emailAttributeURN !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>emailAttributeURN, 'emailAttributeURN');
        }
        if (language !== undefined && language !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>language, 'language');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/sendAccountActivationLinkEmail`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send mail to user\&#39;s preferred email address with link for non-authz password reset. Correct authz information is stored in link\&#39;s URL.
     * @param member id of Member
     * @param namespace namespace
     * @param emailAttributeURN urn of the attribute with stored mail
     * @param language language of the message
     * @param baseUrl base url of Perun instance (optional)
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendPasswordResetLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, baseUrl?: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public sendPasswordResetLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, baseUrl?: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public sendPasswordResetLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, baseUrl?: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public sendPasswordResetLinkEmail(member: number, namespace: string, emailAttributeURN: string, language: string, baseUrl?: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling sendPasswordResetLinkEmail.');
        }
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling sendPasswordResetLinkEmail.');
        }
        if (emailAttributeURN === null || emailAttributeURN === undefined) {
            throw new Error('Required parameter emailAttributeURN was null or undefined when calling sendPasswordResetLinkEmail.');
        }
        if (language === null || language === undefined) {
            throw new Error('Required parameter language was null or undefined when calling sendPasswordResetLinkEmail.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (namespace !== undefined && namespace !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>namespace, 'namespace');
        }
        if (emailAttributeURN !== undefined && emailAttributeURN !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>emailAttributeURN, 'emailAttributeURN');
        }
        if (language !== undefined && language !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>language, 'language');
        }
        if (baseUrl !== undefined && baseUrl !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>baseUrl, 'baseUrl');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/sendPasswordResetLinkEmail`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates a sponsored membership for the given user.
     * @param InputSetSponsoredMember 
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setSponsoredMember(InputSetSponsoredMember: InputSetSponsoredMember, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RichMember>;
    public setSponsoredMember(InputSetSponsoredMember: InputSetSponsoredMember, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RichMember>>;
    public setSponsoredMember(InputSetSponsoredMember: InputSetSponsoredMember, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RichMember>>;
    public setSponsoredMember(InputSetSponsoredMember: InputSetSponsoredMember, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (InputSetSponsoredMember === null || InputSetSponsoredMember === undefined) {
            throw new Error('Required parameter InputSetSponsoredMember was null or undefined when calling setSponsoredMember.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/json/membersManager/setSponsoredMember`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<RichMember>(requestUrl,
            InputSetSponsoredMember,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Transform non-sponsored member to sponsored one, with defined sponsor and optional sponsorship validity expiration
     * @param sponsoredMember id of member to be sponsored
     * @param sponsor id of sponsor
     * @param validityTo date in format yyyy-mm-dd
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setSponsorshipForMember(sponsoredMember: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RichMember>;
    public setSponsorshipForMember(sponsoredMember: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RichMember>>;
    public setSponsorshipForMember(sponsoredMember: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RichMember>>;
    public setSponsorshipForMember(sponsoredMember: number, sponsor: number, validityTo?: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (sponsoredMember === null || sponsoredMember === undefined) {
            throw new Error('Required parameter sponsoredMember was null or undefined when calling setSponsorshipForMember.');
        }
        if (sponsor === null || sponsor === undefined) {
            throw new Error('Required parameter sponsor was null or undefined when calling setSponsorshipForMember.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (sponsoredMember !== undefined && sponsoredMember !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sponsoredMember, 'sponsoredMember');
        }
        if (sponsor !== undefined && sponsor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sponsor, 'sponsor');
        }
        if (validityTo !== undefined && validityTo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>validityTo, 'validityTo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/setSponsorshipForMember`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<RichMember>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Set membership status of a member.
     * @param member id of Member
     * @param status status (VALID | INVALID | EXPIRED | DISABLED)
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public setStatus(member: number, status: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public setStatus(member: number, status: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public setStatus(member: number, status: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public setStatus(member: number, status: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling setStatus.');
        }
        if (status === null || status === undefined) {
            throw new Error('Required parameter status was null or undefined when calling setStatus.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (status !== undefined && status !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>status, 'status');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/setStatus`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Member>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * For an existing member, assigns a new sponsor
     * @param member id of Member
     * @param sponsor id of sponsor
     * @param validityTo date in format yyyy-mm-dd
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sponsorMember(member: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<RichMember>;
    public sponsorMember(member: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<RichMember>>;
    public sponsorMember(member: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<RichMember>>;
    public sponsorMember(member: number, sponsor: number, validityTo?: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling sponsorMember.');
        }
        if (sponsor === null || sponsor === undefined) {
            throw new Error('Required parameter sponsor was null or undefined when calling sponsorMember.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (sponsor !== undefined && sponsor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sponsor, 'sponsor');
        }
        if (validityTo !== undefined && validityTo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>validityTo, 'validityTo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/sponsorMember`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<RichMember>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Assigns a new sponsor to existing members. If some members are non-sponsored, turn them into sponsored and assign the sponsor.
     * @param members id of Member
     * @param sponsor id of sponsor
     * @param validityTo date in format yyyy-mm-dd
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sponsorMembers(members: Array<number>, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public sponsorMembers(members: Array<number>, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public sponsorMembers(members: Array<number>, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public sponsorMembers(members: Array<number>, sponsor: number, validityTo?: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (members === null || members === undefined) {
            throw new Error('Required parameter members was null or undefined when calling sponsorMembers.');
        }
        if (sponsor === null || sponsor === undefined) {
            throw new Error('Required parameter sponsor was null or undefined when calling sponsorMembers.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (members) {
            members.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'members[]');
            })
        }
        if (sponsor !== undefined && sponsor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sponsor, 'sponsor');
        }
        if (validityTo !== undefined && validityTo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>validityTo, 'validityTo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/sponsorMembers`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates sponsorship validity. To change it to FOREVER, don\&#39;t pass the validityTo param, or pass it as null.
     * @param member id of Member
     * @param sponsor id of sponsor
     * @param validityTo date in format yyyy-mm-dd
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateSponsorshipValidity(member: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any>;
    public updateSponsorshipValidity(member: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<any>>;
    public updateSponsorshipValidity(member: number, sponsor: number, validityTo?: string, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<any>>;
    public updateSponsorshipValidity(member: number, sponsor: number, validityTo?: string, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling updateSponsorshipValidity.');
        }
        if (sponsor === null || sponsor === undefined) {
            throw new Error('Required parameter sponsor was null or undefined when calling updateSponsorshipValidity.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }
        if (sponsor !== undefined && sponsor !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>sponsor, 'sponsor');
        }
        if (validityTo !== undefined && validityTo !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>validityTo, 'validityTo');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/updateSponsorshipValidity`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<any>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Validate all attributes for member and set member\&#39;s status to VALID. This method runs asynchronously. It immediately return member with original status and after asynchronous validation successfully finishes it switch member\&#39;s status to VALID. If validation ends with error, member keeps his status.
     * @param member id of Member
     * @param useNon if set to true sends the request to the backend server as 'non' instead of the usual (oauth, krb...).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public validateMemberAsync(member: number, useNon?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<Member>;
    public validateMemberAsync(member: number, useNon?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpResponse<Member>>;
    public validateMemberAsync(member: number, useNon?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<HttpEvent<Member>>;
    public validateMemberAsync(member: number, useNon: boolean = false, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext}): Observable<any> {
        if (member === null || member === undefined) {
            throw new Error('Required parameter member was null or undefined when calling validateMemberAsync.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (member !== undefined && member !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>member, 'member');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarCredential: string | undefined;
        // authentication (BasicAuth) required
        localVarCredential = this.configuration.lookupCredential('BasicAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Basic ' + localVarCredential);
        }

        // authentication (BearerAuth) required
        localVarCredential = this.configuration.lookupCredential('BearerAuth');
        if (localVarCredential) {
            localVarHeaders = localVarHeaders.set('Authorization', 'Bearer ' + localVarCredential);
        }

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let requestUrl = `${this.configuration.basePath}/urlinjsonout/membersManager/validateMemberAsync`;
        if (useNon) {
            // replace the authentication part of url with 'non' authentication
            let helperUrl = new URL(requestUrl);
            let path = helperUrl.pathname.split('/');
            path[1] = 'non';
            helperUrl.pathname = path.join('/');
            requestUrl = helperUrl.toString();
        }
        return this.httpClient.post<Member>(requestUrl,
            null,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
